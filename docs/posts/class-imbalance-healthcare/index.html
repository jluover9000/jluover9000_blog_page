<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jackson Lu">
<meta name="dcterms.date" content="2026-01-16">

<title>When Your 98% Accurate Medical ML Might Be Completely Useless: Understanding Class Imbalance in Healthcare – myblog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">myblog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://jacksonlu.ca/"> <i class="bi bi-backpack" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jluover9000"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/jackson-lu-profiles/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">When Your 98% Accurate Medical ML Might Be Completely Useless: Understanding Class Imbalance in Healthcare</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">machine learning</div>
                <div class="quarto-category">healthcare</div>
                <div class="quarto-category">data science</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Jackson Lu </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 16, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#presentation" id="toc-presentation" class="nav-link active" data-scroll-target="#presentation">Presentation</a></li>
  <li><a href="#introduction-the-fruit-basket-problem" id="toc-introduction-the-fruit-basket-problem" class="nav-link" data-scroll-target="#introduction-the-fruit-basket-problem">Introduction: The Fruit Basket Problem</a></li>
  <li><a href="#the-problem-why-class-imbalance-breaks-ml" id="toc-the-problem-why-class-imbalance-breaks-ml" class="nav-link" data-scroll-target="#the-problem-why-class-imbalance-breaks-ml">The Problem: Why Class Imbalance Breaks ML</a></li>
  <li><a href="#two-approaches-to-solving-the-imbalance-problem" id="toc-two-approaches-to-solving-the-imbalance-problem" class="nav-link" data-scroll-target="#two-approaches-to-solving-the-imbalance-problem">Two Approaches to Solving the Imbalance Problem</a></li>
  <li><a href="#the-great-comparison-what-actually-works" id="toc-the-great-comparison-what-actually-works" class="nav-link" data-scroll-target="#the-great-comparison-what-actually-works">The Great Comparison: What Actually Works?</a>
  <ul class="collapse">
  <li><a href="#tree-based-methods-the-clear-winners" id="toc-tree-based-methods-the-clear-winners" class="nav-link" data-scroll-target="#tree-based-methods-the-clear-winners">Tree-Based Methods: The Clear Winners</a></li>
  <li><a href="#non-tree-methods-smote-makes-the-difference" id="toc-non-tree-methods-smote-makes-the-difference" class="nav-link" data-scroll-target="#non-tree-methods-smote-makes-the-difference">Non-Tree Methods: SMOTE Makes the Difference</a></li>
  </ul></li>
  <li><a href="#real-world-results-the-numbers-dont-lie" id="toc-real-world-results-the-numbers-dont-lie" class="nav-link" data-scroll-target="#real-world-results-the-numbers-dont-lie">Real-World Results: The Numbers Don’t Lie</a></li>
  <li><a href="#practical-takeaways-your-decision-guide" id="toc-practical-takeaways-your-decision-guide" class="nav-link" data-scroll-target="#practical-takeaways-your-decision-guide">Practical Takeaways: Your Decision Guide</a></li>
  <li><a href="#conclusion-accuracy-isnt-enough" id="toc-conclusion-accuracy-isnt-enough" class="nav-link" data-scroll-target="#conclusion-accuracy-isnt-enough">Conclusion: Accuracy Isn’t Enough</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="presentation" class="level2">
<h2 class="anchored" data-anchor-id="presentation">Presentation</h2>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Slide Deck
</div>
</div>
<div class="callout-body-container callout-body">
<p><a href="_presentation.html" class="btn btn-primary" target="_blank">Open slide presentation</a></p>
<p>A quick overview of class imbalance solutions in machine learning.</p>
</div>
</div>
</section>
<section id="introduction-the-fruit-basket-problem" class="level2">
<h2 class="anchored" data-anchor-id="introduction-the-fruit-basket-problem">Introduction: The Fruit Basket Problem</h2>
<p>Imagine you’re teaching a child to recognize different types of fruit. If you show them 100 pictures of apples but only 5 pictures of oranges, they’ll become very good at identifying apples but terrible when they see an orange. This same problem plagues machine learning models in healthcare.</p>
<p>When John, a machine learning engineer at a healthcare tech company, built their first diagnostic model for detecting rare diseases, they were thrilled to see 98% accuracy. But there was a problem: the model achieved this impressive number by simply labeling everything as “normal”. With 10,000 healthy scans and only 200 disease scans in their dataset, the model learned to play it safe. It missed every single actual disease case.</p>
<p>This is the class imbalance problem, and in healthcare, where early detection can mean the difference between life and death, getting it wrong isn’t just a technical failure.</p>
</section>
<section id="the-problem-why-class-imbalance-breaks-ml" class="level2">
<h2 class="anchored" data-anchor-id="the-problem-why-class-imbalance-breaks-ml">The Problem: Why Class Imbalance Breaks ML</h2>
<p>Class imbalance occurs when one category in your dataset significantly outnumbers others. In medical datasets, this is incredibly common: most patients are healthy, most scans are normal, and serious diseases are rare. But this natural imbalance creates a perfect storm for machine learning failure.</p>
<p>The stakes are particularly high in personalized medicine, where we’re moving toward prevention, early diagnosis, and targeted treatment. These approaches demand reliable screening methods to identify at-risk patients before symptoms appear. But if your model can’t recognize rare conditions because it never learned to spot them, the entire promise of personalized medicine collapses.</p>
<p>Standard machine learning classifiers assume balanced datasets. When faced with imbalance, they develop a strong bias toward the majority class. The consequences are severe: algorithms produce misleading accuracy metrics, favor the majority class in predictions, and most dangerously, fail to identify the very patients who need help most urgently. A model that misses cancer cases while correctly identifying thousands of healthy patients is beyond useless.</p>
</section>
<section id="two-approaches-to-solving-the-imbalance-problem" class="level2">
<h2 class="anchored" data-anchor-id="two-approaches-to-solving-the-imbalance-problem">Two Approaches to Solving the Imbalance Problem</h2>
<p>Researchers have tackled class imbalance from two angles: the data level and the algorithm level.</p>
<p><strong>Data-Level Solutions</strong> focus on rebalancing your dataset before training:</p>
<ul>
<li><p><strong>SMOTE (Synthetic Minority Oversampling Technique)</strong>: Creates synthetic examples of the minority class by interpolating between existing samples. Instead of just duplicating rare disease cases, SMOTE generates new, slightly different examples.</p></li>
<li><p><strong>Undersampling</strong>: Reduces the majority class by randomly removing examples. While this balances the dataset, you lose potentially valuable information.</p></li>
<li><p><strong>Hybrid Approach</strong>: Combines both techniques, using SMOTE to generate more minority examples while undersampling the majority class to meet in the middle.</p></li>
</ul>
<p><strong>Algorithm-Level Solutions</strong> modify the learning algorithms themselves:</p>
<ul>
<li><p><strong>Balanced Bagging</strong>: Creates multiple subsets of data, each balanced between classes, and trains separate models on each subset.</p></li>
<li><p><strong>Balanced Random Forest</strong>: Similar to Balanced Bagging but uses decision trees as base learners.</p></li>
<li><p><strong>Cost-Sensitive Learning</strong>: Assigns different costs to misclassifying different classes, making the algorithm pay more attention to rare cases.</p></li>
</ul>
<p>The most effective approach? Combining both levels strategically, depending on which algorithm you’re using.</p>
<blockquote class="blockquote">
<p>“Machine learning is an art—knowing when to use what and how to find a balance.”<br>
— Professor Varada</p>
</blockquote>
</section>
<section id="the-great-comparison-what-actually-works" class="level2">
<h2 class="anchored" data-anchor-id="the-great-comparison-what-actually-works">The Great Comparison: What Actually Works?</h2>
<p>To answer this question, let’s examine real experiments using two critical healthcare datasets: Age-Related Macular Degeneration (AMD) and Preeclampsia detection. These studies tested eight different classification methods with various combinations of SMOTE and undersampling.</p>
<section id="tree-based-methods-the-clear-winners" class="level3">
<h3 class="anchored" data-anchor-id="tree-based-methods-the-clear-winners">Tree-Based Methods: The Clear Winners</h3>
<p><strong>Balanced Bagging</strong> emerged as the champion, achieving <strong>97% balanced accuracy</strong> on the AMD dataset. Unlike regular accuracy, balanced accuracy accounts for performance on both classes, making it a more honest metric for imbalanced data. However, this performance comes at a cost, Balanced Bagging is computationally expensive, requiring significantly more processing time.</p>
<p><strong>Balanced Random Forest</strong> provided an excellent compromise, achieving <strong>96%+ balanced accuracy</strong> with notably faster runtime. For the Preeclampsia dataset, it maintained strong performance with <strong>77%+ balanced accuracy</strong>, demonstrating consistency across different medical conditions.</p>
<p><strong>Gradient Boosting</strong> and standard <strong>Random Forest</strong> also performed admirably, consistently achieving balanced accuracy scores above 96% on AMD and 72% on Preeclampsia. The key insight? Tree-based methods handle imbalance well even without SMOTE or undersampling.</p>
</section>
<section id="non-tree-methods-smote-makes-the-difference" class="level3">
<h3 class="anchored" data-anchor-id="non-tree-methods-smote-makes-the-difference">Non-Tree Methods: SMOTE Makes the Difference</h3>
<p>For algorithms like <strong>K-Nearest Neighbors (KNN)</strong>, <strong>Support Vector Machines (SVM)</strong>, and <strong>Logistic Regression</strong>, the story was different. Without SMOTE and undersampling, these methods struggled with imbalanced data. But with proper data-level techniques:</p>
<ul>
<li><strong>KNN</strong> jumped from 57.96% to <strong>64.44% balanced accuracy</strong> on Preeclampsia when paired with SMOTE</li>
<li><strong>Logistic Regression</strong> jumped from 61.01% to <strong>74.12% balanced accuracy</strong> on Preeclampsia when paired with SMOTE</li>
<li><strong>SVM</strong> showed similar improvements across both datasets</li>
</ul>
<p>This reveals a crucial pattern: <strong>your choice of technique depends entirely on your algorithm</strong>. Tree-based methods have built-in mechanisms to handle imbalance, while non-tree methods desperately need data-level interventions.</p>
</section>
</section>
<section id="real-world-results-the-numbers-dont-lie" class="level2">
<h2 class="anchored" data-anchor-id="real-world-results-the-numbers-dont-lie">Real-World Results: The Numbers Don’t Lie</h2>
<p>Here’s what the experiments revealed across different case reduction scenarios (removing 0% to 90% of majority class samples):</p>
<p><strong>Key Finding #1</strong>: Balanced Bagging and Balanced Random Forest maintained high performance regardless of how aggressively the majority class was reduced. This robustness is critical in healthcare where you might need to work with limited data.</p>
<p><strong>Key Finding #2</strong>: The results were remarkably consistent across both AMD and Preeclampsia datasets, suggesting these findings generalize across different medical conditions.</p>
<p><strong>Key Finding #3</strong>: For tree-based methods, adding SMOTE and undersampling provided minimal improvement—they were already handling imbalance effectively. But for KNN, SVM, and Logistic Regression, these techniques were transformative.</p>
</section>
<section id="practical-takeaways-your-decision-guide" class="level2">
<h2 class="anchored" data-anchor-id="practical-takeaways-your-decision-guide">Practical Takeaways: Your Decision Guide</h2>
<p>If you’re like John, facing an imbalanced healthcare dataset and uncertain which approach to take, here’s your roadmap:</p>
<p><strong>Using Tree-Based Algorithms?</strong></p>
<ul>
<li>First choice: Balanced Random Forest (great performance, reasonable speed)</li>
<li>Best performance: Balanced Bagging (if computational cost isn’t a concern)</li>
<li>Alternative: Gradient Boosting or standard Random Forest</li>
<li>Skip SMOTE/undersampling (you probably don’t need it)</li>
</ul>
<p><strong>Using Non-Tree Algorithms?</strong></p>
<ul>
<li><strong>Always</strong> apply SMOTE and undersampling</li>
<li>KNN and Logistic Regression show particularly strong improvements</li>
<li>Test different SMOTE configurations to find optimal synthetic sample generation</li>
</ul>
<p><strong>Making Trade-offs:</strong></p>
<ul>
<li>Balanced Bagging: Highest accuracy, highest computational cost</li>
<li>Balanced Random Forest: Excellent accuracy-to-speed ratio</li>
<li>Gradient Boosting: Strong middle ground</li>
</ul>
<p><strong>Critical Reminder</strong>: Don’t trust regular accuracy metrics. Always use balanced accuracy or F1-score for imbalanced datasets. That 98% accuracy might just mean your model learned to say “normal” to everything.</p>
</section>
<section id="conclusion-accuracy-isnt-enough" class="level2">
<h2 class="anchored" data-anchor-id="conclusion-accuracy-isnt-enough">Conclusion: Accuracy Isn’t Enough</h2>
<p>Before deploying your medical ML model, remember: the right technique isn’t just about accuracy. It’s about ensuring your model works fairly for ALL patients, including those rare disease cases that matter most. A model that achieves 98% accuracy by missing every cancer case is dangerous.</p>
<p>The solution isn’t one-size-fits-all. Tree-based methods like Balanced Random Forest offer robust out-of-the-box performance. Non-tree methods need help from SMOTE and undersampling. The key is understanding your algorithm’s strengths and weaknesses, then choosing techniques that compensate for its blind spots.</p>
<p>In healthcare, every missed diagnosis is a patient who didn’t get the care they needed. By thoughtfully addressing class imbalance, we can build a systems that recognize not just the common cases, but the critical rare ones too. Only then can we fulfill the promise of personalized medicine, prevention, early diagnosis, and targeted treatment for everyone, not just the statistical majority.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p>IEEE Xplore Document 10705995. Available at: <a href="https://ieeexplore.ieee.org/document/10705995">https://ieeexplore.ieee.org/document/10705995</a></p>
<hr>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/your-website-url\.example\.com");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>